# Developer Log System - Deep Research & Design Document

> **Research Date:** 2026-01-16
> **Status:** Research Complete - Ready for Implementation Planning

---

## Executive Summary

This document presents a comprehensive research and design proposal for a **Developer Log** system in NOIR - a real-time, web-based log viewer for debugging and system monitoring. The system will stream server console/file logs to the browser with intelligent highlighting, filtering, dynamic log level control, and anomaly detection.

### Key Design Principles (from High-Star GitHub Projects)

| Project | Stars | Key Feature We Should Adopt |
|---------|-------|----------------------------|
| **Dozzle** | 11k | Real-time streaming, lightweight, regex search, SQL queries |
| **lnav** | 9.5k | Error/warning index, semantic highlighting, histogram view |
| **Seq** | Industry Standard | Structured log search, dynamic level control via UI, property filtering |
| **Grafana Loki** | 26.9k | Label-based filtering, LogQL queries, cost-effective storage |
| **Logdy** | - | TypeScript-based custom parsers, web UI autogenerated filters |

---

## 1. Architecture Overview

### 1.1 Component Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           NOIR Developer Log System                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────────────────┐  │
│  │   Serilog    │───▶│   Log Ring   │───▶│     LogStreamHub         │  │
│  │   (Sink)     │    │   Buffer     │    │     (SignalR)            │  │
│  └──────────────┘    └──────────────┘    └──────────────────────────┘  │
│         │                   │                        │                   │
│         ▼                   ▼                        ▼                   │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────────────────┐  │
│  │  File Sink   │    │   In-Memory  │    │    WebSocket/SSE         │  │
│  │  (Persistent)│    │   Search     │    │    Real-time Stream      │  │
│  └──────────────┘    └──────────────┘    └──────────────────────────┘  │
│                                                      │                   │
│                                                      ▼                   │
│                            ┌──────────────────────────────────────────┐ │
│                            │           React Frontend                 │ │
│                            │  ┌─────────────────────────────────────┐ │ │
│                            │  │  Log Viewer with Virtual Scrolling  │ │ │
│                            │  │  - Syntax Highlighting              │ │ │
│                            │  │  - Level Filtering                  │ │ │
│                            │  │  - Regex Search                     │ │ │
│                            │  │  - Error Extraction                 │ │ │
│                            │  │  - Timeline Histogram               │ │ │
│                            │  │  - Dynamic Level Control            │ │ │
│                            │  └─────────────────────────────────────┘ │ │
│                            └──────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 Technology Stack

| Layer | Technology | Rationale |
|-------|-----------|-----------|
| Logging | **Serilog** | Already in NOIR, supports structured logging, has `LoggingLevelSwitch` for dynamic control |
| Real-time | **SignalR** | Already in NOIR (NotificationHub), proven pattern, supports fallback transports |
| Buffer | **Circular Buffer** | Fixed memory footprint (configurable 10k-100k entries) |
| Frontend | **React + Virtual List** | Already in NOIR, tanstack/virtual for 100k+ entries |
| Highlighting | **ANSI/Custom Parser** | Parse structured log properties for semantic coloring |

---

## 2. Core Features (Priority Order)

### 2.1 Real-time Log Streaming (P0 - Must Have)

**Research Findings:**
- SignalR is the best choice for .NET apps (auto-fallback to SSE/Long Polling)
- SSE (Server-Sent Events) is simpler but one-way only (sufficient for logs)
- Dozzle uses server-sent events for low overhead

**Implementation Approach:**

```csharp
// LogStreamHub.cs - Similar pattern to existing NotificationHub
public class LogStreamHub : Hub<ILogStreamClient>
{
    public async Task SubscribeToLogs(LogSubscriptionOptions options)
    {
        // options: minLevel, sources[], regex filter, etc.
        await Groups.AddToGroupAsync(Context.ConnectionId, "log_stream");
    }

    public async Task SetMinimumLevel(LogEventLevel level)
    {
        // Dynamic level control per connection
    }

    public async Task ApplyFilter(LogFilterOptions filter)
    {
        // Real-time filter changes without reconnection
    }
}

public interface ILogStreamClient
{
    Task ReceiveLogEntry(LogEntryDto entry);
    Task ReceiveLogBatch(IEnumerable<LogEntryDto> entries);
    Task ReceiveLevelChanged(LogEventLevel newLevel);
}
```

**Frontend Pattern (from Dozzle):**
```typescript
// useLogStream.ts
export function useLogStream(options: LogStreamOptions) {
  const [logs, setLogs] = useState<LogEntry[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const bufferRef = useRef<LogEntry[]>([]);

  // Batch updates for performance (16ms frame budget)
  useEffect(() => {
    const flushInterval = setInterval(() => {
      if (bufferRef.current.length > 0) {
        setLogs(prev => [...prev, ...bufferRef.current].slice(-options.maxEntries));
        bufferRef.current = [];
      }
    }, 16);
    return () => clearInterval(flushInterval);
  }, []);

  // SignalR connection
  useEffect(() => {
    const connection = new HubConnectionBuilder()
      .withUrl('/hubs/logstream')
      .withAutomaticReconnect()
      .build();

    connection.on('ReceiveLogEntry', (entry: LogEntry) => {
      bufferRef.current.push(entry);
    });

    connection.start();
    return () => connection.stop();
  }, []);
}
```

---

### 2.2 Dynamic Log Level Control via UI (P0 - Must Have)

**Research Findings (Serilog + Seq pattern):**

Serilog's `LoggingLevelSwitch` allows runtime level changes without restart:

```csharp
// In Program.cs or DI setup
public static LoggingLevelSwitch LevelSwitch { get; } = new(LogEventLevel.Information);

builder.Host.UseSerilog((context, configuration) =>
{
    configuration
        .MinimumLevel.ControlledBy(LevelSwitch)  // Key feature!
        .MinimumLevel.Override("Microsoft", LogEventLevel.Warning)
        .MinimumLevel.Override("System", LogEventLevel.Warning)
        .ReadFrom.Configuration(context.Configuration)
        .Enrich.FromLogContext()
        .WriteTo.Console()
        .WriteTo.SignalR(logStreamService);  // Custom sink for real-time
});

// Register as singleton for API access
builder.Services.AddSingleton(LevelSwitch);
```

**API Endpoint for UI Control:**
```csharp
// LogLevelEndpoints.cs
public static void MapLogLevelEndpoints(this IEndpointRouteBuilder app)
{
    var group = app.MapGroup("/api/admin/log-level")
        .RequireAuthorization("AdminOnly");

    group.MapGet("/", (LoggingLevelSwitch levelSwitch) =>
        new { Level = levelSwitch.MinimumLevel.ToString() });

    group.MapPut("/", (LogLevelRequest request, LoggingLevelSwitch levelSwitch) =>
    {
        if (Enum.TryParse<LogEventLevel>(request.Level, out var level))
        {
            levelSwitch.MinimumLevel = level;
            return Results.Ok(new { Level = level.ToString() });
        }
        return Results.BadRequest("Invalid log level");
    });

    // Per-source level overrides (advanced)
    group.MapPut("/override/{source}", ...);
}
```

**Frontend Control Panel:**
```typescript
// LogLevelControl.tsx
const levels = ['Verbose', 'Debug', 'Information', 'Warning', 'Error', 'Fatal'];

function LogLevelControl() {
  const [currentLevel, setCurrentLevel] = useState('Information');

  return (
    <Select value={currentLevel} onValueChange={async (level) => {
      await api.put('/api/admin/log-level', { level });
      setCurrentLevel(level);
      toast.success(`Log level changed to ${level}`);
    }}>
      {levels.map(level => (
        <SelectItem key={level} value={level}>
          <Badge variant={getLevelVariant(level)}>{level}</Badge>
        </SelectItem>
      ))}
    </Select>
  );
}
```

---

### 2.3 Syntax Highlighting & Semantic Coloring (P1 - High Priority)

**Research Findings (from lnav, klp, Dozzle):**

Best log viewers use **semantic highlighting** - not just regex-based coloring:

| Element | Color | Example |
|---------|-------|---------|
| Timestamp | Gray/Muted | `2026-01-16 10:30:45.123` |
| Level: Verbose/Debug | Cyan | `[DBG]` |
| Level: Information | Green | `[INF]` |
| Level: Warning | Yellow/Amber | `[WRN]` |
| Level: Error/Fatal | Red | `[ERR]` `[FTL]` |
| Exception Type | Bold Red | `NullReferenceException` |
| Stack Trace | Monospace Red | `at Namespace.Class.Method()` |
| HTTP Status 2xx | Green | `200 OK` |
| HTTP Status 4xx | Amber | `404 Not Found` |
| HTTP Status 5xx | Red | `500 Internal Server Error` |
| Duration (>1s) | Amber | `1234ms` |
| IP Addresses | Blue Underline | `192.168.1.1` |
| URLs | Blue Underline | `https://api.example.com` |
| GUIDs | Purple | `a1b2c3d4-e5f6-7890-...` |
| JSON | Syntax Highlighted | `{"key": "value"}` |
| SQL | Syntax Highlighted | `SELECT * FROM Users` |

**Implementation Approach:**

```typescript
// logHighlighter.ts
interface HighlightRule {
  pattern: RegExp;
  className: string;
  priority: number;
}

const HIGHLIGHT_RULES: HighlightRule[] = [
  // Log levels
  { pattern: /\[(VRB|DBG|DEBUG)\]/gi, className: 'text-cyan-500', priority: 10 },
  { pattern: /\[(INF|INFO)\]/gi, className: 'text-green-500', priority: 10 },
  { pattern: /\[(WRN|WARN|WARNING)\]/gi, className: 'text-amber-500', priority: 10 },
  { pattern: /\[(ERR|ERROR|FTL|FATAL)\]/gi, className: 'text-red-500 font-bold', priority: 10 },

  // Timestamps
  { pattern: /\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}(\.\d+)?/g, className: 'text-muted-foreground', priority: 5 },

  // HTTP methods & status
  { pattern: /\b(GET|POST|PUT|DELETE|PATCH)\b/g, className: 'text-blue-400 font-semibold', priority: 8 },
  { pattern: /\b[2]\d{2}\b/g, className: 'text-green-500', priority: 7 },  // 2xx
  { pattern: /\b[4]\d{2}\b/g, className: 'text-amber-500', priority: 7 },  // 4xx
  { pattern: /\b[5]\d{2}\b/g, className: 'text-red-500', priority: 7 },    // 5xx

  // Exception patterns
  { pattern: /\b\w+Exception\b/g, className: 'text-red-500 font-bold', priority: 9 },
  { pattern: /^\s+at .+$/gm, className: 'text-red-400 text-sm font-mono', priority: 8 },  // Stack trace

  // Identifiers
  { pattern: /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/gi, className: 'text-purple-400', priority: 6 },
  { pattern: /\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/g, className: 'text-blue-400 underline', priority: 6 },

  // Duration warnings
  { pattern: /\b(\d{4,}ms|\d+\.\d+s)\b/g, className: 'text-amber-500 font-semibold', priority: 7 },

  // JSON inline
  { pattern: /\{[^}]+\}/g, className: 'text-violet-400 font-mono text-sm', priority: 4 },
];

export function highlightLogEntry(text: string): React.ReactNode[] {
  // Apply rules by priority, return array of spans
  return applyHighlightRules(text, HIGHLIGHT_RULES);
}
```

---

### 2.4 Search & Filtering (P1 - High Priority)

**Research Findings (from Seq, lnav):**

Best-in-class log search supports multiple modes:

1. **Free-text search** - Simple substring matching
2. **Regex search** - Full regex with capture groups
3. **Structured query** - `Level = 'Error' AND Source like 'NOIR.%'`
4. **Property filtering** - Click on any property value to filter

**Implementation:**

```typescript
// LogFilter.tsx
interface LogFilterState {
  search: string;
  searchMode: 'text' | 'regex' | 'structured';
  levels: LogLevel[];
  sources: string[];
  timeRange: { from: Date; to: Date } | null;
  showOnlyErrors: boolean;
}

function LogFilter({ onFilterChange }: { onFilterChange: (f: LogFilterState) => void }) {
  return (
    <div className="flex flex-wrap gap-2 p-4 border-b">
      {/* Search input with mode toggle */}
      <div className="flex-1 min-w-[300px]">
        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 text-muted-foreground" />
          <Input
            placeholder="Search logs... (supports regex with /pattern/)"
            className="pl-10 pr-20"
          />
          <Select className="absolute right-2 top-1/2 -translate-y-1/2 w-16">
            <SelectItem value="text">Text</SelectItem>
            <SelectItem value="regex">Regex</SelectItem>
            <SelectItem value="sql">SQL</SelectItem>
          </Select>
        </div>
      </div>

      {/* Level filter chips */}
      <div className="flex gap-1">
        {['Debug', 'Info', 'Warn', 'Error'].map(level => (
          <Toggle key={level} variant="outline" size="sm">
            <Badge variant={getLevelVariant(level)}>{level}</Badge>
          </Toggle>
        ))}
      </div>

      {/* Quick filters */}
      <Button variant="outline" size="sm">
        <AlertCircle className="w-4 h-4 mr-1" />
        Errors Only
      </Button>

      {/* Source dropdown */}
      <SourceFilter sources={availableSources} />

      {/* Time range */}
      <DateRangePicker />
    </div>
  );
}
```

---

### 2.5 Error/Issue Extraction & Anomaly Detection (P2 - Important)

**Research Findings (from Elastic, Zebrium, academic papers):**

Modern log analysis uses multiple techniques:

| Technique | Use Case | Implementation |
|-----------|----------|----------------|
| **Pattern Recognition** | Group similar errors | Drain algorithm, LCS clustering |
| **Anomaly Scoring** | Detect unusual log rates | Time-series analysis, baseline deviation |
| **Correlation Clustering** | Find related errors | Temporal proximity + semantic similarity |
| **Error Deduplication** | Reduce noise | Hash-based grouping of similar messages |

**Simplified Implementation for NOIR:**

```typescript
// errorExtraction.ts
interface ErrorCluster {
  id: string;
  pattern: string;
  count: number;
  firstSeen: Date;
  lastSeen: Date;
  samples: LogEntry[];
  severity: 'low' | 'medium' | 'high' | 'critical';
}

// Group errors by normalized pattern
function extractErrorClusters(logs: LogEntry[]): ErrorCluster[] {
  const errors = logs.filter(l => l.level === 'Error' || l.level === 'Fatal');
  const clusters = new Map<string, ErrorCluster>();

  for (const error of errors) {
    const normalizedPattern = normalizeErrorMessage(error.message);
    const hash = hashPattern(normalizedPattern);

    if (clusters.has(hash)) {
      const cluster = clusters.get(hash)!;
      cluster.count++;
      cluster.lastSeen = error.timestamp;
      if (cluster.samples.length < 5) cluster.samples.push(error);
    } else {
      clusters.set(hash, {
        id: hash,
        pattern: normalizedPattern,
        count: 1,
        firstSeen: error.timestamp,
        lastSeen: error.timestamp,
        samples: [error],
        severity: determineSeverity(error),
      });
    }
  }

  return Array.from(clusters.values())
    .sort((a, b) => b.count - a.count);
}

// Normalize error messages (remove variable parts)
function normalizeErrorMessage(message: string): string {
  return message
    .replace(/\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/gi, '<UUID>')
    .replace(/\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/g, '<IP>')
    .replace(/\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}/g, '<TIMESTAMP>')
    .replace(/\d+/g, '<NUM>');
}
```

**Error Summary Panel:**
```typescript
// ErrorSummaryPanel.tsx
function ErrorSummaryPanel({ clusters }: { clusters: ErrorCluster[] }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <AlertCircle className="text-red-500" />
          Error Summary ({clusters.length} patterns)
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-2">
          {clusters.slice(0, 10).map(cluster => (
            <div
              key={cluster.id}
              className="flex items-center justify-between p-2 rounded-lg bg-red-50 dark:bg-red-900/20"
            >
              <div className="flex-1 truncate">
                <code className="text-sm">{cluster.pattern}</code>
              </div>
              <Badge variant="destructive">{cluster.count}x</Badge>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  );
}
```

---

### 2.6 Log Timeline Histogram (P2 - Important)

**Research Findings (from lnav, Grafana):**

A histogram showing log volume over time helps identify:
- Traffic spikes
- Error clusters
- Quiet periods (potential issues)

```typescript
// LogHistogram.tsx
function LogHistogram({ logs, timeRange, onBrush }: LogHistogramProps) {
  const buckets = useMemo(() => {
    const bucketCount = 100;
    const bucketDuration = (timeRange.to - timeRange.from) / bucketCount;
    const result = new Array(bucketCount).fill(null).map((_, i) => ({
      start: new Date(timeRange.from.getTime() + i * bucketDuration),
      counts: { debug: 0, info: 0, warn: 0, error: 0 },
    }));

    for (const log of logs) {
      const bucketIndex = Math.floor(
        (log.timestamp.getTime() - timeRange.from.getTime()) / bucketDuration
      );
      if (bucketIndex >= 0 && bucketIndex < bucketCount) {
        result[bucketIndex].counts[log.level.toLowerCase()]++;
      }
    }

    return result;
  }, [logs, timeRange]);

  return (
    <div className="h-16 flex items-end gap-px">
      {buckets.map((bucket, i) => {
        const total = Object.values(bucket.counts).reduce((a, b) => a + b, 0);
        const maxHeight = 48;
        const height = Math.min(maxHeight, Math.log(total + 1) * 10);

        return (
          <div
            key={i}
            className="flex-1 flex flex-col-reverse cursor-pointer hover:opacity-80"
            onClick={() => onBrush(bucket.start)}
          >
            {/* Stacked bars by level */}
            <div style={{ height: height * (bucket.counts.error / total) }} className="bg-red-500" />
            <div style={{ height: height * (bucket.counts.warn / total) }} className="bg-amber-500" />
            <div style={{ height: height * (bucket.counts.info / total) }} className="bg-green-500" />
            <div style={{ height: height * (bucket.counts.debug / total) }} className="bg-cyan-500" />
          </div>
        );
      })}
    </div>
  );
}
```

---

## 3. Advanced Features (P3 - Future)

### 3.1 Per-Source Log Level Override

```csharp
// Allow overriding specific namespaces
public class DynamicLogLevelService
{
    private readonly ConcurrentDictionary<string, LoggingLevelSwitch> _sourceOverrides = new();

    public void SetSourceLevel(string sourcePrefix, LogEventLevel level)
    {
        var switch = _sourceOverrides.GetOrAdd(sourcePrefix, _ => new LoggingLevelSwitch());
        switch.MinimumLevel = level;
    }
}
```

### 3.2 Log Correlation with Request ID

Link logs from the same request together:

```csharp
// Already available via Serilog's RequestLogging middleware
app.UseSerilogRequestLogging(options =>
{
    options.EnrichDiagnosticContext = (diagnosticContext, httpContext) =>
    {
        diagnosticContext.Set("RequestId", httpContext.TraceIdentifier);
        diagnosticContext.Set("UserId", httpContext.User?.FindFirst("sub")?.Value);
    };
});
```

### 3.3 Log Export & Download

```typescript
// Export visible logs as JSON/CSV
function exportLogs(logs: LogEntry[], format: 'json' | 'csv') {
  const content = format === 'json'
    ? JSON.stringify(logs, null, 2)
    : convertToCSV(logs);

  downloadFile(`logs_${Date.now()}.${format}`, content);
}
```

### 3.4 Log Persistence Options

| Option | Pros | Cons |
|--------|------|------|
| In-Memory Only | Fast, simple | Lost on restart |
| Rolling Files | Persistent, searchable | Disk I/O |
| SQLite | Queryable, indexed | More complex |
| External (Seq/Loki) | Full-featured | Requires setup |

---

## 4. UI/UX Design Guidelines

### 4.1 Page Layout

```
┌─────────────────────────────────────────────────────────────────────────┐
│ Developer Logs                                              [Admin] [?] │
├─────────────────────────────────────────────────────────────────────────┤
│ ┌─────────────────────────────────────────────────────────────────────┐ │
│ │ [Search...                    ] [Text ▼] [DBG] [INF] [WRN] [ERR]   │ │
│ │ [Source: All ▼] [Time: Last 1h ▼]  [●Live] [⟳ Refresh] [↓ Export]  │ │
│ └─────────────────────────────────────────────────────────────────────┘ │
│ ┌─────────────────────────────────────────────────────────────────────┐ │
│ │                    [Timeline Histogram - 1h window]                  │ │
│ │ ▁▂▃▄▅▆▇█▇▆▅▄▃▂▁▁▂▃▄▅▆▇▇▆▅▄▃▂▁ (red = errors, green = info)        │ │
│ └─────────────────────────────────────────────────────────────────────┘ │
│ ┌───────────────────────────────────────────────────┐┌─────────────────┐│
│ │                                                    ││ Error Summary   ││
│ │ 10:30:45.123 [INF] HTTP GET /api/users 200 15ms   ││                 ││
│ │ 10:30:45.456 [WRN] Slow query detected: 1234ms    ││ NullRef... (5x) ││
│ │ 10:30:45.789 [ERR] NullReferenceException:        ││ Timeout... (3x) ││
│ │    at NOIR.Application.Features...                 ││                 ││
│ │    at NOIR.Web.Endpoints...                        ││ [View All →]    ││
│ │ 10:30:46.012 [INF] User login successful          │└─────────────────┘│
│ │ 10:30:46.345 [DBG] Cache hit for key: user_123    │┌─────────────────┐│
│ │                                                    ││ Log Level       ││
│ │ [Virtual scrolling - 10,000+ entries]             ││                 ││
│ │                                                    ││ [Information ▼] ││
│ │                                                    ││                 ││
│ │                                                    ││ [● Info]        ││
│ │                                                    ││ [○ Debug]       ││
│ │                                                    ││ [○ Verbose]     ││
│ └───────────────────────────────────────────────────┘└─────────────────┘│
│ ┌─────────────────────────────────────────────────────────────────────┐ │
│ │ Status: ● Connected | 12,453 entries | 45 errors | 2.3 MB buffer    │ │
│ └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.2 Key UX Patterns (from Research)

1. **Auto-scroll with pause** - Scroll to bottom for new logs, pause when user scrolls up
2. **Click-to-filter** - Click any value (level, source, IP) to add filter
3. **Keyboard shortcuts** - `Ctrl+F` search, `G` go to bottom, `E` next error
4. **Persist filters** - Remember user's preferred filters in localStorage
5. **Dark mode optimized** - Logs are often viewed in dark environments

---

## 5. Security Considerations

### 5.1 Access Control

```csharp
// Only admins can view developer logs
app.MapHub<LogStreamHub>("/hubs/logstream")
    .RequireAuthorization("AdminOnly");

// Log level changes require elevated permissions
app.MapPut("/api/admin/log-level", ...)
    .RequireAuthorization("SystemAdmin");
```

### 5.2 Sensitive Data Filtering

```csharp
// Mask sensitive data before streaming
public class SensitiveDataMaskingEnricher : ILogEventEnricher
{
    private static readonly Regex[] SensitivePatterns = new[]
    {
        new Regex(@"password['""]?\s*[:=]\s*['""]?[^'""]+", RegexOptions.IgnoreCase),
        new Regex(@"bearer\s+[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+", RegexOptions.IgnoreCase),
        new Regex(@"api[_-]?key['""]?\s*[:=]\s*['""]?[^'""]+", RegexOptions.IgnoreCase),
    };

    public void Enrich(LogEvent logEvent, ILogEventPropertyFactory factory)
    {
        // Mask sensitive data in log message
    }
}
```

### 5.3 Rate Limiting

```csharp
// Prevent log flooding attacks
services.Configure<LogStreamOptions>(options =>
{
    options.MaxEntriesPerSecond = 1000;
    options.MaxEntrySize = 64 * 1024;  // 64KB
    options.BufferSize = 100_000;
});
```

---

## 6. Performance Considerations

### 6.1 Backend Performance

| Aspect | Target | Implementation |
|--------|--------|----------------|
| Memory | <50MB | Circular buffer with fixed size |
| Latency | <100ms | Batch sends every 16ms |
| Throughput | 10k logs/sec | Async buffered writes |

### 6.2 Frontend Performance

| Aspect | Target | Implementation |
|--------|--------|----------------|
| Render | 60fps | Virtual scrolling (tanstack/virtual) |
| Memory | <100MB | Keep max 10k entries in state |
| Search | <50ms | Web Worker for filtering |

---

## 7. Implementation Roadmap

### Phase 1: Foundation (1-2 sprints)
- [ ] Create `LogStreamHub` (copy NotificationHub pattern)
- [ ] Create custom Serilog sink for SignalR streaming
- [ ] Implement in-memory circular buffer
- [ ] Basic React log viewer with virtual scrolling
- [ ] Level filtering (client-side)

### Phase 2: Core Features (1-2 sprints)
- [ ] Dynamic log level control via UI
- [ ] Syntax highlighting
- [ ] Regex search
- [ ] Source filtering
- [ ] Log entry detail view (expand/collapse)

### Phase 3: Advanced Features (2-3 sprints)
- [ ] Timeline histogram
- [ ] Error clustering/extraction
- [ ] Log download/export
- [ ] Per-source level overrides
- [ ] Correlation by request ID

### Phase 4: Polish (1 sprint)
- [ ] Keyboard shortcuts
- [ ] Persistent user preferences
- [ ] Performance optimization
- [ ] Documentation

---

## 8. References

### GitHub Projects (High Stars)
- **Dozzle** (11k stars) - https://github.com/amir20/dozzle
- **lnav** (9.5k stars) - https://github.com/tstack/lnav
- **Grafana Loki** (26.9k stars) - https://github.com/grafana/loki
- **Logdy** - https://github.com/logdyhq/logdy-core
- **klp** - https://github.com/dloss/klp

### Documentation
- Serilog LoggingLevelSwitch - https://nblumhardt.com/2014/10/dynamically-changing-the-serilog-level/
- Seq Dynamic Level Control - https://datalust.co/docs/using-serilog
- SignalR Streaming - https://learn.microsoft.com/aspnet/core/signalr/streaming

### Research Papers
- "Clustering Logs for Effective Log-based Anomaly Detection" - ClusterLog
- "Deep Learning for Anomaly Detection in Log Data: A Survey"

---

## 9. Log Level Philosophy

### HTTP Response Code to Log Level Mapping

NOIR uses a deliberate log level strategy that distinguishes between **user/business logic failures** and **system failures**:

| HTTP Status Code | Log Level | Rationale |
|------------------|-----------|-----------|
| **2xx** (Success) | INFO | Normal successful operations |
| **4xx** (Client Error) | **WARNING** | Business logic failures (validation, not found, forbidden, conflict). The system is working correctly - it correctly rejected an invalid request. |
| **5xx** (Server Error) | **ERROR** | System failures (exceptions, infrastructure issues). Something is broken and needs attention. |

### Why 4xx = WARNING (Not ERROR)

This is an intentional design decision based on industry best practices:

1. **Semantic Meaning**: 4xx responses indicate the *client* made a mistake (bad input, unauthorized access, resource not found). The server correctly identified and rejected the request - this is *expected behavior*.

2. **Noise Reduction**: If 4xx responses logged as ERROR, common scenarios like "user tried to delete a protected tenant" would flood error dashboards with false alarms.

3. **Alerting Strategy**: Only 5xx (ERROR level) should trigger production alerts. 4xx are normal business operations.

### Examples

| Scenario | HTTP Code | Log Level | Why |
|----------|-----------|-----------|-----|
| User deletes protected tenant | 400 Bad Request | **WARNING** | Business rule correctly enforced |
| User access denied | 403 Forbidden | **WARNING** | Auth system working correctly |
| User tries to access deleted entity | 404 Not Found | **WARNING** | Expected behavior for invalid ID |
| Database connection failed | 500 Internal Server Error | **ERROR** | System failure - needs investigation |
| Unhandled exception | 500 Internal Server Error | **ERROR** | Bug - needs fixing |

### Implementation Details

Serilog request logging is configured in `Program.cs` to map status codes to log levels:

```csharp
app.UseSerilogRequestLogging(options =>
{
    options.GetLevel = (context, elapsed, ex) =>
    {
        if (ex != null) return LogEventLevel.Error;

        var statusCode = context.Response.StatusCode;
        return statusCode switch
        {
            >= 500 => LogEventLevel.Error,   // System failure
            >= 400 => LogEventLevel.Warning, // Business logic failure
            _ => LogEventLevel.Information   // Success
        };
    };
});
```

### Activity Log vs Developer Log Display

| Log Type | What Shows as "Error" |
|----------|----------------------|
| **Activity Log** | Both WARNING and ERROR (shows all failures) |
| **Developer Log "Errors only" filter** | WARNING + ERROR level logs (captures all failures) |

The Activity Log uses red "Error" badges for any failed operation (Result.Failure), regardless of whether it's a business logic failure (4xx/WARNING) or system failure (5xx/ERROR), because from the user's perspective, the action failed.

The Developer Log filter "Errors only" includes WARNING level to capture business logic failures that resulted in failed operations, even though they're not system errors.

---

## 10. Appendix: Comparison Matrix

| Feature | Seq | Dozzle | lnav | Grafana | NOIR (Proposed) |
|---------|-----|--------|------|---------|-----------------|
| Real-time streaming | ✅ | ✅ | ❌ | ✅ | ✅ |
| Web UI | ✅ | ✅ | ❌ | ✅ | ✅ |
| Dynamic level control | ✅ | ❌ | ❌ | ❌ | ✅ |
| Syntax highlighting | ✅ | Basic | ✅ | Basic | ✅ |
| Error clustering | ❌ | ❌ | ✅ | ❌ | ✅ |
| Timeline histogram | ❌ | ❌ | ✅ | ✅ | ✅ |
| Self-hosted | ✅ | ✅ | ✅ | ✅ | ✅ |
| Zero dependency | ❌ | ✅ | ✅ | ❌ | ✅ |
| .NET native | ✅ | ❌ | ❌ | ❌ | ✅ |

---

**Document Prepared By:** Claude (Research Agent)
**Review Status:** Ready for team review
